### 28.4 Evaluating Locks
- Before build any locks, we should first understand what our goals are,and thus we ask how to evaluate the efficacy of particular lock implementation.To evaluate whether a lock works (and works well), we should establish some basic criteria. The first is whether the lock does its basic task,which is to provide mutual exclusion.Basically,does the lock work,preventing multiple threads from entering a critical section?
- The second is fairness.Does each thread contending for the lock get a fair shot at acquiring it once it is free? Another way to look at this is by examining the more extreme case: does any thread contending for the lock starve while doing so, thus never obtaining it?
- The final criterion is performance ,specifically the time overheads added by using the lock. There are a few different cases that are whorth considering here. One is the case of no contention;when a single thread is running and grabs and releases the lick, what is the overhead of doing so? Anotheris the case where multiple threads are contending for the lock a single CPU; in this case, are there performance concerns? Finally,how does the lock perform when there are multiple CPUs involved, and threads on each contending for the lock? By comparing these different scenarios, we can better understand the performance impact of using various locking techniques,as described below.
### 28.5 Controlling Interrupts
- ONe of the earlies solutions used to provide mutual exclusion was to disable interrupts for critical sections;the solution was invented for single-procesor systems.
- Assume we are running on such a single-processor system.By turning off interrupts(using some kind of special hardware instructions) before entering a critical section, we ensure that the code inside the critical section will not be interrupted, and thus will execute as if it were atomic.When we are finished,we re enable-interrputs(again, via a hardware instruction) and thus the program proceeds as usual.
- 